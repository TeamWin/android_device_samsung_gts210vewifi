#!/sbin/sh
#
###########################################################################
# MIT License
#
# Copyright (c) 2019 Julien Milletre @ Akipe
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
###########################################################################
#
# This script is based on steadfasterX script "readtimeprop.sh" \
#   https://github.com/steadfasterX \
#   https://forum.xda-developers.com/member.php?u=5545101 \
#   Thank to him <3
#
# Edited by Akipe \
#   https://github.com/Akipe \
#   https://forum.xda-developers.com/member.php?u=8175453
#
###########################################################################
#
# Set time on TWRP with choosing timekeep or time_daemon (Qualcomm),
# depending of ROM (AOSP & LineageOS based, or Stock ROM).
# To properly prepare this scipt, you have to :
# - import init config with "init.fixtime.rc"
# - build timekeep from the LineageOS repository
# - include time_daemon binary and it's dependencies
# 
# Todo :
# - test and rewrite function "set_time_for_qcom_time"
# - check existing prop "persist.vendor.timeadjust"
# - search ROMs with support timekeep with EGREP_RULE_DETECT_TIMEKEEP_ROM
###########################################################################
VERSION="0.0.1";
PROGNAME="fixtime";
AUTHOR="Akipe";

###########################################################################
# Configuration
###########################################################################

DEBUG_ENABLE=0
LOG_FILE_PATH=/tmp/recovery.log
TMP_SYSTEM_MOUNT_PATH=/system_temp
BUILD_PROP_PATH_FROM_SYSTEM_TEMP="$TMP_SYSTEM_MOUNT_PATH/build.prop"
QCOM_TIME_DAEMON=time_daemon
TIMEKEEP_DAEMON=timekeep
LOG_MODULE_NAME=fixtime
EGREP_RULE_DETECT_TIMEKEEP_ROM='(aosp|aoscp|aicp|lineage|cyanogenmod|^cm_|^omni_)'

###########################################################################
# Global variables
###########################################################################

is_fstab_generated=0
time_engine_type_used_by_rom=0
timeadjust=""
date_before_fix=""

###########################################################################
# Functions
###########################################################################

write_log() {
  local type="$1"
  local message="$2"

  echo "$type:[$LOG_MODULE_NAME] $message" >> $LOG_FILE_PATH
}

write_info_log() {
  local message="$1"

  write_log "I" "$message"
}

write_error_log() {
  local message="$1"

  write_log "E" "$message"
}

search_system_in_fstab() {
  grep -q "/system" /etc/fstab && is_fstab_generated=1
}

# The fstab gets auto generated by twrp after running through the partition checkup
# We need to wait until it gets generated to avoid issues!
# Refer to: bootable/recovery/partitionmanager.cpp
verify_system_is_mount() {
  write_info_log "Checking for twrp fstab..."

  search_system_in_fstab

  while [ "$is_fstab_generated" -eq 0 ]; do
    write_info_log "No twrp fstab which includes /system generated yet! will wait until its there.."
    sleep 2
    search_system_in_fstab
  done

  write_info_log "/system found in twrp fstab: '$(grep '/system' /etc/fstab)'"
}

mount_temp_system() {
  local system_mount_path="$1"

  write_info_log "Mount system to tempory directory: $system_mount_path"

  mkdir $system_mount_path
  mount -t ext4 /dev/block/bootdevice/by-name/system $system_mount_path 2>&1 >> $LOG_FILE_PATH \
    || mount -t f2fs /dev/block/bootdevice/by-name/system $system_mount_path 2>&1 >> $LOG_FILE_PATH

  write_info_log "$(mount | grep \"$system_mount_path\" )"
}

get_build_flavor_name_from_system_buildprop() {
  echo $(grep "ro.build.flavor" $BUILD_PROP_PATH_FROM_SYSTEM_TEMP|cut -d "=" -f 2)
}

detect_time_engine_with_flavor_name() {
  local build_flavor_name="$1"

  echo "$build_flavor_name" | egrep -i $EGREP_RULE_DETECT_TIMEKEEP_ROM >> /dev/null

  if [ $? -eq 0 ]; then
    time_engine_type_detected_from_prop=timekeep;
  else
    time_engine_type_detected_from_prop=qcomtime;
  fi
}

detect_rom_type() {
  write_info_log "build.prop from temp system path : $BUILD_PROP_PATH_FROM_SYSTEM_TEMP"

  [ ! -r $BUILD_PROP_PATH_FROM_SYSTEM_TEMP ] && \
    write_error_log "Cannot determine installed OS! time will may not work properly.. falling back to qcomtime.."
  
  [ $DEBUG_ENABLE -eq 1 ] && [ -r $BUILD_PROP_PATH_FROM_SYSTEM_TEMP ] && \
    write_info_log "Your build entries in yours ROM build.prop: $(grep build $BUILD_PROP_PATH_FROM_SYSTEM_TEMP)"

  unset time_engine_type_used_by_rom

  find $TMP_SYSTEM_MOUNT_PATH -name $QCOM_TIME_DAEMON | \
    grep $QCOM_TIME_DAEMON 2>&1 >> $LOG_FILE_PATH && \
    time_engine_type_used_by_rom=qcomtime
  
  find $TMP_SYSTEM_MOUNT_PATH -name $TIMEKEEP_DAEMON | \
    grep $TIMEKEEP_DAEMON 2>&1 >> $LOG_FILE_PATH && \
    time_engine_type_used_by_rom=timekeep

  build_flavor_name=$(get_build_flavor_name_from_system_buildprop)

  detect_time_engine_with_flavor_name $build_flavor_name

  # fallback if the regular detection fails
  [ -z $QCOM_TIME_DAEMON ] && [ -z $TIMEKEEP_DAEMON ] && \
    time_engine_type_used_by_rom=$time_engine_type_detected_from_prop && \
    write_error_log "Binary detection failed! using fallback.."

  write_info_log "ROM type detected: $time_engine_type_used_by_rom (flavor: $build_flavor_name)"

  [ -z "$time_engine_type_used_by_rom" ] && \
    write_error_log "ROM TYPE cannot be detected!!! Flavor: $build_flavor_name"
}

# Todo: check if system_mount_path correctly unmount
umount_temp_system() {
  local system_mount_path="$1"

  write_info_log "Umount tempory system '$system_mount_path' ..."

  umount $system_mount_path && \
    rm -Rf $system_mount_path && \
    write_info_log "'$system_mount_path' unmout !"
}

remove_time_file_and_log() {
  local time_file_name="$1"
  local path_to_time_file="$2"
  local path_to_time_files_to_remove="$3"

  [ -f $path_to_time_file ] && rm $path_to_time_files_to_remove && \
    write_info_log "$time_file_name: We are on a $time_engine_type_used_by_rom ROM so deleted unneeded qcomtime ROM file: $path_to_time_files_to_remove"
}

wait_until_data_is_mount() {
  local data_property_path="/data/property"

  write_info_log "Wait until /data is mount..."

  while [ ! -d "$data_property_path" ]; do
    sleep 2
  done
}

wait_until_persistent_properties_is_accessible() {
  local persistent_properties_file_path="/data/property/persistent_properties"

  write_info_log "Wait until persistent_properties is accessible..."

  while [ ! -f "$persistent_properties_file_path" ]; do
    sleep 2
  done
}

load_persist_prop() {
  write_info_log "Reload persist prop after /data as been mount"

  setprop twrp.fixtime.load_persist_props true # This trigger load persist prop, look at init.fixtime.rc
}

wait_until_twrp_ready() {
  wait_until_data_is_mount
  wait_until_persistent_properties_is_accessible
  load_persist_prop
}

## Todo: rewrite this function, never tested and problably buggy
## Todo: check if time_daemon exist
set_time_for_qcom_time() {
  write_info_log "QCOM time based ROM!"
  write_info_log "If you feel this is an error you may have and unidentified custom ROM flavor installed!"
  write_info_log "Paste this line in the TWRP thread: flavor = $build_flavor_name"

  if [ -r /data/time/ats_1 ]||[ -r /data/time/ats_2 ]||[ -r /data/system/time/ats_1 ]||[ -r /data/system/time/ats_2 ]; then
    # we are on STOCK so we do not need custom ROM time file
    # todo: unset persist.sys.timeadjust & persist.vendor.timeadjust
    write_info_log "Proprietary qcom time-file detected! Will start qcom time_daemon instead of timekeep!"
    
    # trigger time_daemon
    setprop twrp.fixtime.use_timedaemon 1
  else
    write_error_log "We expected $time_engine_type_used_by_rom ROM but proprietary qcom time files missing! Cannot set time!"
    write_error_log "$(ls -la /data/time/ /data/system/time/)"
  fi
}

get_timeadjust() {
  write_info_log "Trying to get timeadjust..."

  if [ ! -z "$(getprop persist.sys.timeadjust)" ]; then
    timeadjust="$(getprop persist.sys.timeadjust)"
    write_info_log "Find timeadjust with 'persist.sys.timeadjust' : $timeadjust"

  elif [ ! -z "$(getprop persist.vendor.timeadjust)" ]; then
    timeadjust="$(getprop persist.vendor.timeadjust)"
    write_info_log "Find timeadjust with 'getprop persist.vendor.timeadjust' : $timeadjust"

  else
    write_error_log "Unable to get 'timeadjust' from getprop!"
  fi
}

## Todo: check if timekeep exist
set_time_for_keeptime() {
  get_timeadjust
  
  if [ ! -z "$timeadjust" ]; then
    write_info_log "Timeadjust value: $timeadjust"

    # when coming from STOCK those are obsolete!
    remove_time_file_and_log "atsa1" "/data/time/ats_1" "/data/time/ats_*"
    remove_time_file_and_log "atsa2" "/data/time/ats_2" "/data/time/ats_*"
    remove_time_file_and_log "atsb1" "/data/system/time/ats_1" "/data/system/time/ats_*"
    remove_time_file_and_log "atsb2" "/data/system/time/ats_2" "/data/system/time/ats_*"
  
    # trigger timekeep daemon
    setprop twrp.fixtime.use_timekeep 1
  else
    write_error_log "timekeep can't been launched! Cannot set time!"
  fi
}

###########################################################################
# App execution
###########################################################################

main() {
  verify_system_is_mount
  mount_temp_system $TMP_SYSTEM_MOUNT_PATH
  detect_rom_type
  umount_temp_system $TMP_SYSTEM_MOUNT_PATH
  wait_until_twrp_ready

  date_before_fix="$(date)"

  if [ "$time_engine_type_used_by_rom" == "qcomtime" ]; then
    set_time_for_qcom_time
  else
    set_time_for_keeptime
  fi

  write_info_log "Date change from '$date_before_fix' to '$(date)'"
}

main "$@"

write_info_log "$0 finished"
